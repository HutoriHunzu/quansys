import qutip as qt
from .space import Space


class CompositeSpace:
    """
    A structure for which we incorporate all the spaces in our system
    Keep the order for tensor products
    """

    def __init__(self, *args: Space):
        """
        :param args: each arg need to be of type Space
        """
        if not args:
            raise ValueError("CompositeSpace requires at least one Space")
        for space in args:
            if not isinstance(space, Space):
                raise ValueError("All arguments must be Space instances")
        
        # Check for duplicate names
        names = [space.name for space in args]
        if len(names) != len(set(names)):
            raise ValueError("All spaces must have unique names")
            
        self.spaces_ordered = args
        self.spaces: dict[str | int, Space] = {space.name: space for space in self.spaces_ordered}

    def tensor(self, name_op_dict):
        """
        :param name_op_dict: dictionary of {Name: Op} where the name has to be
        the name of one of the spaces. The Op need to be an operator generated by the Space
        :return: Tensor Product of the operators. Assuming identity if wasn't mentioned otherwise
        """
        # Validate that all names exist
        invalid_names = set(name_op_dict.keys()) - set(self.spaces.keys())
        if invalid_names:
            raise ValueError(f"Unknown space names: {invalid_names}")
        
        op_lst = []
        for space in self.spaces_ordered:
            if space.name in name_op_dict:
                op_lst.append(name_op_dict[space.name])
            else:
                op_lst.append(space.eye())
        return qt.tensor(*op_lst)

    def get_operator(self, name, op_type, **kwargs):
        """
        :param name: name of Space
        :param op_type: name for the type of Operator (as input of Space class)
        :param args: other arguments for the creation of the Operator
        :return: Tensor product of the newly created operator with identity for all other spaces
        """
        if name not in self.spaces:
            raise ValueError(f"Unknown space name: {name}")
        if not hasattr(self.spaces[name], op_type):
            raise ValueError(f"Space {name} does not have operator type: {op_type}")
        
        op = getattr(self.spaces[name], op_type)(**kwargs)
        return self.tensor({name: op})

    def expand_operator(self, name, operator):
        """
        :param name: Name of the Space
        :param operator: an operator of the Space (which has the given name)
        :return: tensor product with Identity for all other Spaces
        """
        if name not in self.spaces:
            raise ValueError(f"Unknown space name: {name}")
        
        return self.tensor({name: operator})