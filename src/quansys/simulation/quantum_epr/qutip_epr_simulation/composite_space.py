import qutip as qt
from .space import Space


class CompositeSpace:
    """
    A structure for which we incorporate all the spaces in our system
    Keep the order for tensor products
    """

    def __init__(self, *args: Space):
        """
        :param args: each arg need to be of type Space
        """
        self.spaces_ordered = args
        self.spaces: dict[str | int, Space] = {space.name: space for space in self.spaces_ordered}

    def tensor(self, name_op_dict):
        """
        :param name_op_dict: dictionary of {Name: Op} where the name has to be
        the name of one of the spaces. The Op need to be an operator generated by the Space
        :return: Tensor Product of the operators. Assuming identity if wasn't mentioned otherwise
        """
        op_lst = []
        for space in self.spaces_ordered:
            if space.name in name_op_dict:
                op_lst.append(name_op_dict[space.name])
            else:
                op_lst.append(space.eye())
        return qt.tensor(*op_lst)

    def get_operator(self, name, op_type, **kwargs):
        """
        :param name: name of Space
        :param op_type: name for the type of Operator (as input of Space class)
        :param args: other arguments for the creation of the Operator
        :return: Tensor product of the newly created operator with identity for all other spaces
        """
        op = getattr(self.spaces[name], op_type)(**kwargs)
        return self.tensor({name: op})

    def expand_operator(self, name, operator):
        """
        :param name: Name of the Space
        :param operator: an operator of the Space (which has the given name)
        :return: tensor product with Identity for all other Spaces
        """
        d = {name: operator}
        residual_names = set(self.spaces.keys()) - {name}
        for space_name in residual_names:
            d[space_name] = self.spaces[space_name].eye()
        return self.tensor(d)